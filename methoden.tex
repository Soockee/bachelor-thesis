% ----------------------------------------------------------------------------
% Copyright (c) 2016 by Burkhardt Renz. All rights reserved.
% Die Vorlage für eine Abschlussarbeit in der Informatik am Fachbereich
% MNI der THM ist lizenziert unter einer Creative Commons
% Namensnennung-Nicht kommerziell 4.0 International Lizenz.
%
% Id:$
% ----------------------------------------------------------------------------
\chapter{Die untersuchten Sprachen}
\section{Die Sprache C}
C ist eine universell einsetzbare Programmiersprache. Zudem ist C eine relativ hardwarenahe Sprache. Diese Eigenschaft ist nicht abwertend zu verstehen. Es bedeutet nur, dass C mit der gleichen Art von Objekten umgeht, wie Computer. Genauer gesagt Zahlen, Zeichen und Adressen. Es gibt auch keine Heap- oder Garbage collection.\cite{Kernighan.1988}
\section{Die Sprache R}
Die Sprache R wird hauptsächlich für \emph{statistical Computing} eingesetzt. R besteht nicht nur aus der Sprache selbst, sonder auch einer Laufzeitumgebung mit Grafiken, einem Debugger, Zugang zu verschiedenen Systemfunktionen und der Möglichkeit Scripte auszuführen.\\
Viele in R genutzte mathematische Funktionen sind selbst in R geschrieben, dennoch lassen sich auch in C/C++ oder FORTRAN geschriebene Funktionen in R nutzen\cite{.05.10.2017}

\section{Relevante unterschiede der Sprachen}
Der relevenateste Unterschied zwischen den Sprachen C und R ist, dass C eine kompilierte und R eine interpretierte Sprache ist.\\
Ein großer Vorteil von R ist die Entwicklungszeit, die gebraucht wird, um Programme zu schreiben.
Für die naive Implementierung zum invertieren von Matrizen wurde in C insgesamt 235 Zeilen Code geschrieben. Im Gegensatz dazu der R Code mit nur 21 Zeilen, wovon 15 zeilen dafür zuständig sind, sich um Ausgabe und Zeitmessung zu kümmern. Auch die Lesbarkeit ist in R oftmals besser, was zum einem an dem geringeren Umfang des Programmcodes liegt und zum anderen an den komplizierteren Sprachkonstrukten von C.
\chapter{Messmethode zur Ermittlung der Rechenzeit}
\section{Messen der Gesamtlaufzeit mithilfe eines system call}
Zur Berechnung der Gesamtlaufzeit wurde ein Tool entwickelt, das eine Shell imitiert. Innerhalb dieser Shell lassen sich ausführbare Programme oder Systemkommandos aufrufen. Diese werden ausgeführt und anschließend deren Gesamtlaufzeit im Benutzermodus in \emph{clock-ticks} ausgegeben. Damit lassen sich exakte Laufzeiten eines Programms ermitteln, ohne von äußeren Einflüsssen, wie dem Prozessor Scheduler oder im Kernel Mode ausgeführte Funktionen wie z.B. print Funktionen, beinflusst zu werden. Allerdings fließt die Initialisierungszeit, der in dieser Arbeit benutzten Programme, d.h. die Belegung einer Matrix mit Zufallswerten usw. mit in die Gesamtlaufzeit ein. Auch die Anzahl der Iterationen, also die Anzahl an zufälligen Matrizen, die invertiert werden, spielt eine ausschlaggebende Rolle. Deshalb wird diese gemessene Zeit nur als Prüfwert benutzt, um sicherzustellen, dass die Summe der gemessenen Zeiten pro Iteration, mit der im nächsten Abschnitt vorgestellten Methode, ungefähr mit der Gesamtlaufzeit des Programmes übereinstimmmt.
\section{Messen der Laufzeit einer Iteration durch Zeitdifferenz zwischen Codeabschnitten}
Um die durschnittliche Laufzeit einer Iteration zu ermitteln, wird eine Zeitmessung durchgeführt, die nur den Teil des Programms umfasst, der sich mit dem Finden der Inversen einer Matrix beschäftigt. Anschließend wird die Summe aller Iterationszeiten durch die Anzahl der Iterationen geteilt, um den Durschnitt zu erhalten.\\
Problematiken bei dieser Messmethode sind leider unausweichlich. So entstehen z.B. Schwankungen der Rechenzeiten, aufgrund von Kontextwechsel bzw. Taskswitching der CPU.

\chapter{Verwendete mathematische Funktion}
\section{Gauss-Jordan Algorithmus}
Der Gauss-Jordan Algorithmus kann in 3 Schritten durchgeführt werden.
Dabei sei vorausgesetzt, dass die Matrix quadratisch und ihre Determinate ungleich 0 ist. Die naive Implementierung in C und das Matlib Packet in R setzen genau diesen Algorithmus um.

Der Gauss-Jordan Algorithmus wird anhand eines Beispiels genauer erläutert.

Gegeben seien folgende Matrizen A und B:

\[
A:
\left\{\begin{tabular}{ccc}
0 & 2 & 0 \\
4 & 5 & 6 \\
0 & 0 & 9
\end{tabular}
\right\}\quad
B:
\left\{\begin{tabular}{ccc}
1 & 0 & 0 \\
0 & 1 & 0\\
0 & 0 & 1
\end{tabular}
\right\}
\]
\begin{enumerate}
	\item Transformation der ggb. Matrix in die Einheitsmatrix und anwenden aller Operationen auf die mitgeführte Matrix.
	\[
	\left\{\begin{tabular}{ccc|ccc}
	0 & 2 & 0 & 1 & 0 & 0 \\
	4 & 5 & 6 & 0 & 1 & 0\\
	0 & 0 & 9 & 0 & 0 & 1
	\end{tabular}
	\right\}
	\]
	\begin{enumerate}[label*=\arabic*]
		\item Reduziere Matrix zu Stufenform
			\[
		\left\{\begin{tabular}{ccc|ccc}
		4 & 5 & 6 & 0 & 1 & 0 \\
		0 & 2 & 0 & 1 & 0 & 0\\
		0 & 0 & 9 & 0 & 0 & 1
		\end{tabular}
		\right\}	Tausche\,Reihe\,1\,mit\,Reihe 2
		\]
		\item Reduziere Matrix zu reduzierter Stufenform
		\[
		\left\{\begin{tabular}{ccc|ccc}
		4 & 5 & 0 & 0 & 1 & $-\frac{2}{3}$ \\
		0 & 2 & 0 & 1 & 0 & 0\\
		0 & 0 & 9 & 0 & 0 & 1
		\end{tabular}
		\right\}	Reihe\;1 - Reihe\;3 * (6 / 9)
		\]
		\\
		\[
		\left\{\begin{tabular}{ccc|ccc}
		4 & 0 & 0 & -2,5 & 1 & $-\frac{2}{3}$ \\
		0 & 2 & 0 & 1 & 0 & 0\\
		0 & 0 & 9 & 0 & 0 & 1
		\end{tabular}
		\right\}	Reihe\;1 - Reihe\;2 * (5 / 2)
		\]
		\item Teile Reihe der rechte Teilmatrix durch Diagonalelement der Reihe der linken Teilmatrix
		\[
		\left\{\begin{tabular}{ccc|ccc}
		1 & 0 & 0 & $-\frac{5}{8}$ & $\frac{1}{4}$ & $-\frac{2}{3}$ \\
		0 & 1 & 0 & $\frac{1}{2}$ & 0 & 0\\
		0 & 0 & 1 & 0 & 0 & $\frac{1}{9}$
		\end{tabular}
		\right\}
		\]
	\end{enumerate}
\end{enumerate}
Durch diese 3 Schritte erhalten wir nun das Inverse der untersuchten Matrix. Es ist das Nebenprodukt der Operationen, die gebraucht werden, um die ggb. Matrix in eine Einheitsmatrix zu transformieren.

\[
Inverse(A): 
	\left\{\begin{tabular}{ccc}
	$-\frac{5}{8}$ & $\frac{1}{4}$ & $-\frac{2}{3}$ \\
	$\frac{1}{2}$ & 0 & 0\\
	0 & 0 & $\frac{1}{9}$
\end{tabular}
\right\}
\]

\section{Optimierte Gaußsche Eliminationsverfahren}
Dieses Verfahren wird in GSL (GNU Scientific Library) und in LAPACK (Linear Algebra PACKage) verwendet. Die Programme mit den besten gemessenen Laufzeiten, benutzten jeweils eines der Pakete.

Entsprechen der Dokumentation von LAPACK\cite{.13.11.2017} kann der DGESV Algorithmus wie folgt abgeleitet werden:

Der DGSV Algorithmus berechnet die Lösung eines linearen Gleichungssystems
\[A * X = B\]
Dabei sei A eine NxN Matrix. X und B seien NxM Matrizen, wobei M für die Anzahl der Spalten von B steht.

Die LR-Zerlegung 
arbeitet mit Pivotisierung. Das Pivotelement beschreibt das erste Element, welches benutzt wird um eine Rechnung durchzuführen. Dieses Pivotelement wird ggf. durch Reihentausch angepasst. Die LR-Zerlegung wird benutzt um A in 3 Teile zu unterteilen.
\[A = P * L * U\]
P steht hierbei für die  Permutationsmatrix, einer Matrix die Vertauschungen darstellt.\\L steht für die untere Dreiecksmatrix.\\ U steht für die obere Dreiecksmatrix.\\
Diese unterteilte Form wird benutzt, um lineare Gleichungssystem A * X = B zu lösen.
% ----------------------------------------------------------------------------
