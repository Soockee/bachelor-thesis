% ----------------------------------------------------------------------------
% Copyright (c) 2016 by Burkhardt Renz. All rights reserved.
% Die Vorlage für eine Abschlussarbeit in der Informatik am Fachbereich
% MNI der THM ist lizenziert unter einer Creative Commons
% Namensnennung-Nicht kommerziell 4.0 International Lizenz.
%
% Id:$
% ----------------------------------------------------------------------------

\chapter{Design}
\label{chapter:Design}
In diesem Kapitel werden die in \cref{chapter:Problembeschreibung} beschriebenen Problemstellung bearbeitet. Anfänglich werden Designziele definiert, die den Rahmen für die Konzipierung bilden. In \cref{section:Datenmodell} wird ein Datenmodell vorgestellt, welches sich an Standards von bereits existierenden Tracingmodellen orientiert. \cref{section:Verarbeitungsmodell} präsentiert ein Konzept zur verarbeitung der erhobenen Tracingdaten. Der \cref{section:Visualisierung} beschäftigt sich mit der Darstellung der Tracingdaten zur Informationsgewinnen durch den Anwender der Bibliothek. Somit wird ein Konzept für die Tracinginfrastruktur zur Erhebung, Verarbeitung und Visualisierung von Tracingdaten vorgestellt.

\section{Designziele}
\label{section:Designziele}

Aus den in \cref{section:Anforderungsanalyse} beschriebenen Anforderungen folgern Designziele, die an das Design gestellt werden. Die von Google erstellte Fachpublikation \emph{Dapper, a Large-Scale Distributed Systems Tracing Infrastrcture} dient vielen Tracingsystemen als konzeptionelle Grundlage. In der Puplikation werden Designziele aufgeführt, die neue Tracingsysteme bewerten sollten. Es werden Designziele bewertet, die von Dapper genannt werden. Ausserdem sind zusätzliche Designziele aufgezeigt, die aus den Anforderungen des verteilten rendering Systems hervorkommen. Diese Designziele umfassen die (\lowroman{1}) \textbf{Verarbeitungskosten}, die (\lowroman{2}) \textbf{Benutzbarkeit}, die (\lowroman{3}) \textbf{Portabilität} und die (\lowroman{4}) \textbf{Datenverfügbarkeit}. Ausserdem werden Nicht-Ziele definiert. Zu diesen gehören die (\lowroman{5}) \textbf{Anwendungs-Level Transparenz} und die (\lowroman{6}) \textbf{Skalierbarkeit}.

\subsection{Ziele}
\label{subsection:Ziele}
\textbf{Verarbeitungskosten} \space\space\space Ein für die Performance der Anwendung kritisches Designziel, in der Tracing eingeführt werden soll, stellt der \textbf{Overhead} dar. Der Overhead, der durch die Instrumentalisierung entsteht, soll möglichst gering sein. So kann etwa in spezialisierten hochperfomanten Services kleinster, durch Instrumentalisierung entstehender Mehraufwand, deutlich merkbar sein.\footpartcite{Shanbhag2010}. 

\textbf{Benutzbarkeit} \space\space\space Die Benutzbarkeit des Tracingsystems soll durch die Verwendung von Standards gewährleistet sein. Die von \emph{Opentracing} veröffentlichte \gls{apiLabel} soll der Instrumentalisierungsbibliothek eine vertraute und bewährte Anwendererfahrung liefern. 

\textbf{Portabilität} \space\space\space Ein weiteres Designziel soll eine gegebene \textbf{Portabilität} sein. Die Umgebung für die das Tracingsystem entwicklet wird, ist eine Mischung aus Platformabhängigen und Platformunabhängigen Komponenten. Durch den verminderten Mehraufwand der bei platformunabhängigen Komponeten entsteht, wird eine verbesserte Nutzerfreundlichkeit gewährleistet. Vorallem bei der Integration in bestehende Systeme wird dies bemerkbar, da Bauprozesse von Projekten platformabhängig sind. Der platformabhängige Bauprozess soll im Falle des verteilten rendering System nicht beeinflusst werden. Die 

\textbf{Datenverfügbarkeit} \space\space\space Die Datenverfügbarkeit soll zeitnah stattfinden. Die von der Tracinginfrastruktur generierten Tracingdaten sollen zur Laufzeit darsgestellt werden. 

\subsection{Nicht-Ziele}
\label{subsection:Nicht-Ziele}

Die von Dapper genannten Designziele der \emph{Anwendungs-Level Transparenz} und der \emph{Skalierbarkeit} spielen für das verteilte rendering System eine untergeordnete Rolle. Diese Bewertung hat ihren Ursprung aus einer interpretierten Form eines Sprichworts. 

\begin{quote}
	Du bist nicht Google, also versuch auch nicht Google zu sein
\end{quote}

Dapper ist für eine Infrastruktur konzipiert, die globalen  Maßstäben entspricht. Das verteilte rendering System entspricht nicht diesen Maßstäben, somit soll auch die Tracinginfrastruktur diese nicht erfüllen müssen. Die beiden Deisgnziele von Dapper werden als Nicht-Ziele für das verteilte rendering System bewertet.

\textbf{Anwendungs-Level Transparenz}\space\space\space Instrumentalisierung erfordert eingreifen in Anwendungsquellcode. Dapper löst dies durch Ausnutzung von Bibliotheken. Diese werden Instrumentalisiert und in der Anwendungslogik verwendet. Somit ist die Tracinginfrastruktur für den Anwendungsentwickler nicht wahrnehmbar. Die Instrumentalisierung des verteilten rendering Systems soll an semantisch relevanten Bereichen stattfinden und flexibel sein. Dies gelingt durch direktes modifizieren der Anwendungslogik. Der Anwendungsentwickler muss sich dementsprechend selbst um die Instrumentalisierung kümmern. 

\textbf{Skalierbarkeit} \space\space\space Das verteilte rendering System ist, in seiner einfachsten Form, statisch. Das bedeutet, dass eine Skalierbarkeit keine zentrale Rolle in dem Design der Tracinginfrastruktur darstellt. Die Skalierbarkeit soll allerdings bewertet werden. 

\section{Datenmodell}
\label{section:Datenmodell}

\textbf{F1: }Inwiefern lässt sich eine Zeitmessung von Eventzeitspannen konzipieren

In diesem Abschnitt wird das Problem \textbf{F1} diskutiert.
Dieses Problem erfordert die Konzipierung eines Datenmodells, welches drei Aspekte berücksichtig. Der erste Aspekt wird durch die Zeitspanne des Events selbst dargestellt. Dabei muss das Event derart repräsentiert werden, sodass eine Zeitspanne als Information daraus gewonnen werden kann. Die detailierte Darstellung wird in \cref{subsection:Spans} erläutert. Der zweite Aspekt entsteht durch die Gegebenheit eines lokalen Kontexts. Dieser wird in \cref{subsection:Tracingcontext innerhalb eines Systems} beschrieben. Der dritte Aspekt ist durch die Kommuniktion von Komponenten des Systems gegeben. Dieser wird  in \cref{subsection:Tracingcontext über Systemgrenzen} dargestellt.


Das Datenmodell beruht auf dem Spanmodell, welches in der vorher beschrieben Fachpuplikation \emph{Dapper} vorgestellt, durch die Spezifikation von \emph{Opentracing} erweitert und dem Anwendungsfall des verteilten rendering Systems und des Entwicklungsprojekts angepasst wird.

Ein Überblick über das Spanmodell wird gezeigt. Ein \emph{Trace} bildet die größte Einheit des Modells ab. Traces sind Eventsammlungen, die den Weg einer Anfrage durch ein verteiltes System darstellen.Ein Trace ist die Reise der Anfrage, wohingegen einzelne Events die Etappen dieser Reise sind.Die Events werden weiterführend als Spans bezeichnet.  Ein Trace beinhaltet ein bis beliebig viele \emph{Spans}. Ein Span ist die kleinste Einheit eines Traces. Spans bilden einen Arbeitsprozess innerhalb eines Prozesses ab. Innerhalb eines \emph{Threads} ist zu jeder Zeit nur ein Span \emph{aktiv}.


\subsection{Spans}
\label{subsection:Spans}
\begin{figure}[!ht]
	\centering
	\includegraphics[scale=0.7]{img/Design/Span.png}
	\caption[Zeitliche Darstellung eines Spans]{Darstellung eines Spans mit Anfangszeit, Endzeit und Operationsnamen}
	\label{fig:SpanThreadKontext}
\end{figure}



\subsection{Tracingcontext innerhalb eines Systems}
\label{subsection:Tracingcontext innerhalb eines Systems}

\begin{figure}[!ht]
	\centering
	\includegraphics[scale=0.5]{img/Design/SpanThreadKontext.png}
	\caption[Tracingkontexts in einem Threads innerhalb einer Anwendung]{Anwendung mit einem Thread. Ein von der Instrumentalisierung veranlasster Kontextwechsel innerhalb eines Threads}
	\label{fig:SpanThreadKontext}
\end{figure}


Ein Prozess kann \emph{Threads} implementieren. Die Events, die in einem Thread stattfinden, können ihren Lebenszyklus entweder in diesem beginnen und beenden oder in einem Thread beginnen und in einem anderen Thread enden. Der Tracer, also die übergeordnete Verwaltungseinheit, muss jedoch jederzeit feststellen können, welches Event \emph{aktiv} ist. Der Grund dafür ist beispielsweise das Erstellen von Relationen für zu generierende Events, die ihr Elternevent kennen müssen. Eine Umgebung ist notwendig, in der der aktive Span festgestellt werden kann. Diese Umgebung wird als \emph{Scope} bezeichnet. Der Kontext eines Traces ergibt sich aus dem aktiven Span. Der Kontext ist notwendig, um folgende Spans zuordnen zu können. Anhand der aufgeführten Beispiele wird das Konzept des Scopes verdeutlicht. Dabei beinhaltet das erste Beispiel, dargestellt in \cref{fig:SpanThreadKontext}, einen Thread, indem zwei Traces parallel exisitieren. Die \cref{fig:SpanMultipleThreadKontext} stellt die Situation eines Traces über mehrere Threads dar.

Im ersten Beisiel sei gegeben, dass eine Anwendung ein Thread implementiert. Dabei exisiteren zwei parallele Traces. Trace 1 beinhaltet das Event 1. Event 1 sendet asynchron eine große Datei an ein Frontend, wie dies in dem verteilten rendering System der Fall sein könnte.  Trace 2 beinhaltet Event 2. Event 2 liest eine kleinen Datei aus einem Speicher. Es wird davon ausgegangen, dass das Schreiben deutlich mehr Zeit beansprucht, als das Lesen. Der Ablauf des Kontextwechsels beginnt mit der Erstellnug und Aktivierung des Spans, welcher Event 1 umfasst. Die Aktivierung des Spans sorgt dafür, dass dieser in dem \emph{Scope} wandert. Der Scope verwaltet den aktiven Span. Die Startzeit des Spans wird gespeichert und die Anwendungslogik asynchron bearbeitet. Event 2, welches zu Trace 2 gehört, startet und generiert den zweiten Span. Dabei findet Kontextwechsel K1 statt. K1 tauscht den Span von Event 1 mit dem Span von Event 2. Der Span von Event 2 ist nun aktiv und der Span von Event 1 nimmt implizit den Zustand \emph{nicht beendet} ein. Die Anwendungslogik, die Event 2 darstellt, wird bearbeitet. Das Event 2 beendet, woraus die Schließung des dazugehörigen Spans folgert. Die Endzeit wird gespeichert. Trace 2 schließt, da der Span von Event 2 keinen \emph{ElternID} beinhaltet und somit der Wurzelspan ist. K2 wechselt wieder den aktiven Span. Danach beendet Event 1, da der \emph{Callback}, durch die Beendigung des Schreibens, aufgerufen wird. Entsprechenden schließt Span von Event 1. Auch hier ist dieser der Elternspan und schließt Trace 1 ab. Zu jedem Zeitpunkt kann des Tracerobjekt feststelle, welches das aktive Span ist.


\begin{figure}[!ht]
	\centering
	\includegraphics[scale=0.5]{img/Design/SpanMultipleThreadKontext.png}
	\caption[Tracingkontexts über mehrere Threads innerhalb einer Anwendung]{Anwendung mit zwei Threads. Ein von der Instrumentalisierung veranlasster Kontextwechsel zwischen Threads}
	\label{fig:SpanMultipleThreadKontext}
\end{figure}

Im zweiten Beispiel sei gegeben, dass eine Anwendung zwei Threads implementiert. Es exisitert ein Trace, welches Event 1 beinhaltet. Thread 1 beinhaltet Event 1. Event 1 sorgt für die die Erstellung eines Scopes in dem der Span von Event 1 erstellt und aktiviert wird. Kontextwechsel K1 findet statt. Der Scope schließt in Thread 1 schließt. Da Event 1 in Thread 2 weitergeführt wird, beendet der Span nicht bei K1. In Thread 2 findet die Weiterführung von Event 1 statt, weshalb ein Scope eröffnet wird. In diesem Scope wird der in dem vorherigen Scope aktive Span eingeführt. Dies stellt die Kontextübermittlung dar. Event 1 endet anschließend und Trace 1 wird geschlossen.

Diese beiden Beispiele zeigen die Relevanz von Scopes zur Verfolgung des Kontexts innerhalb eines Systems ohne Netzwerkkommunikation. Sie lösen das Problem der Kontextverfolgbarkeit. Damit lassen sich Endzeiten von Spans innerhalb eines Systems, auch über Threadgrenzen hinaus, bestimmen. 

\subsection{Tracingcontext über Prozessgrenzen}
\label{subsection:Tracingcontext über Systemgrenzen}

Die Kontextverfolgung über Prozessgrenzen stellt wohl das schwierigste Problem im verteilten tracing dar.


\section{Verarbeitungsmodell}
\label{section:Verarbeitungsmodell}
\subsection{Agenten}
\label{subsection:Agenten}
\subsection{Collectoren}
\label{subsection:Collectoren}

\section{Visualisierung}
\label{section:Visualisierung}

\subsection{Tracegraph}
\subsection{Dreidimensionale Flammengraphen}
\begin{figure}[!ht]
	\centering
	\includegraphics[scale=0.3]{img/Problembeschreibung/flamegraph_3D.png}
	\caption[3D Flammengraph]{Skizzierung eines dreidimensionalen Flammengraphs mit Nachrichtenaustausch}
	\label{fig:flamegraph_3D}
\end{figure}

% ----------------------------------------------------------------------------
