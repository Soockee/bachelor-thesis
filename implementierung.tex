% ----------------------------------------------------------------------------
% Copyright (c) 2016 by Burkhardt Renz. All rights reserved.
% Die Vorlage für eine Abschlussarbeit in der Informatik am Fachbereich
% MNI der THM ist lizenziert unter einer Creative Commons
% Namensnennung-Nicht kommerziell 4.0 International Lizenz.
%
% Id:$
% ----------------------------------------------------------------------------
\chapter{Implementierung}
\label{chapter:Implementierung}

In diesem Kapitel werden Implementierungen von Prototypen gezeigt, die im Kapitel \cref{chapter:Design} besprochen sind. In \cref{section:Instrumentalisierungsbibliothek: Traktor} werden die implementierungsdetails der Instrumentalisierungsbilbiothek \textbf{Traktor} vorgestellt. In \cref{section:Traktor Agent} und in \cref{section:Traktor Registry} werden die Traktor Services beschrieben. Anschließend werden zwei Anwendungsfälle gezeigt. Der Anwendungsfall des rendering System in \cref{section:Unity Rendering System} und der Anwendungsfall einer verteilten Webanwendung in \cref{section:Webserver Entwicklungsumgebung}

\section{Instrumentalisierungsbibliothek: Traktor}
\label{section:Instrumentalisierungsbibliothek: Traktor}
In diesem Kapitel wird die Implementierung der Instrumentalisierungsbibliothek Traktor vorgestellt. Es wird das Datenmodell umgesetzt, welches in \cref{section:Datenmodell} konzipiert ist und gezeigt inwiefern Traktor die Anforderungen erfüllt.

Traktor ist eine Instrumentalisierungsbibliothek, die sich die OpenTracing API als Vorbild nimmt. Die OpenTracing API ist eine herstellerneutrale instrumentalisierungs API, die unter der Schirmherschafft der \gls{cncfLabel} steht, welches Teil der gemeinnützig agierenden \gls{lfLabel} ist.

Die zwei zentralen Einheiten der Traktor Instrumentalisierungsbibliothek sind der in \cref{subsection:Tracer} gezeigte \textbf{Tracer} und der in \cref{subsection:Span} \textbf{Spans}. Weitere Klassen, die den in \cref{subsection:Tracingcontext innerhalb eines Systems} beschriebenen Designansatz implementieren, sind der in \cref{subsection:Scope} vorgestellte Scope und der in \cref{subsection:ScopeManager} vorgestellte ScopeManager. Die Kontextpropagierung, die mit einer Websocketverbindung innerhalb des Tracer und der, in \cref{section:Traktor Registry} gezeigten, Traktor Registry, umgesetzt ist, implementiert den in \cref{subsection:Tracingcontext über Systemgrenzen} erläuterten Designansatz. Ein Gesamtüberblick mit allen Relationen der Klassen, wird in \cref{subsection:UML-Klassendiagramm der Bibliothek} gegeben.

\subsection{Tracer}
\label{subsection:Tracer}
Der Tracer ist die zentrale Verwaltungseinheit der Instrumentalisierung. Dieser verwaltet die Verbindung der Anwendungsinstrumentalisierung zu dem Agenten und der Registry. Der Tracer kümmert sich um das Generieren von Spans und die Herstellung von Kausalzusammenhängen zwischen den Spans. Ausserdem stellt der Tracer die Funktionalitäten zur Kontextpropagierung über die Registry bereit. Die Spans sind Darstellungen von ausgeführter Arbeit in einer instrumentalisierten Anwendung. 

Die Tracer API erweitert die OpenTracing API um vier Funktionen, die notwendig sind, um sich mit der Tracinginfrastuktur zu verbinden. Die \emph{Configure} Funktion sorgt für einen Verbindungsaufbau, abhängig von den übergebenen Parametern. Ein vollständiger Verbindungsaufbau ist nötig, um eine Kontextpropagierung zu ermögliche. Ausserdem wird der \gls{udpLabel} Klient initzialisiert, damit beendete Spans reportet werden können. Der UDP-Klient hat einen Port zu belegen, der angegeben werden muss. Die IP-Adressen der Services sind dem Tracer bekannt zu geben. Auch der Port auf der die Anwendung lauscht, muss übergeben werden. Die Configure Funktion verwendet die \emph{Register} Funktion zur Erstellung einer \textbf{WebSocketClient} Instanz. Die Websocketverbindung wird über die Lebensdauer des Tracer offen gehalten. Über diesen Kommunikationskanal werden die Kontextinformationen übermittelt. \cref{listing:Tracer Verbindungsaufbau} zeigt eine Beispielhafte Konfigurierung. Dabei wird eine Tracerinstanz instanziiert und mit den Adressen der Traktorservices konfiguriert.

\begin{minipage}[]{\textwidth}
	\begin{lstlisting}[frame=trBL]
	using Traktor;
	
	var registryAddress = "localhost";
	var registryPort = "8080";
	var agentAddress = "localhost"
	var agentPort = 13337;
	var reporterPort = 13338;
	
	Tracer tracer = new Tracer()
	tracer.Configure(registryAddress,registryPort,agentAddress,
				agentPort,reporterPort);
	
	\end{lstlisting}
	\captionof{lstlisting}{Tracer Verbindungsaufbau mit der Registry und dem Reporter }
	\label{listing:Tracer Verbindungsaufbau}
\end{minipage} 

Die Kontextdaten werden in einer \emph{Carrier} Instanz gespeichert und über die Leitung gesendet. In der Implementierung gibt es einen Carriertyp. Der BinaryCarrier ist ein Datencontainer, der die Kontextinformationen als MemoryStream speichert. Der MemoryStream speichert die Daten im Arbeitsspeicher als Bytearray. Das Format würde für die Übertragung über eine TCP/IP Verbindung ausgewählt. 
Die Spangenerierung wird durch eine \emph{SpanBuilder} Instanz geregelt. Der Operationsname wird der SpanBuilder Instanz mitgegeben und für die Generierung des Spans genutzt. Die Kontextpropagierung wird durch die beiden sich ergänzenden asynchronen Funktionen \emph{SendContext} und \emph{ReceiveContext} implementiert. Diese nutzen die \emph{Extract} und \emph{Inject}, um die BinaryCarrier zu erstellen beziehungsweise die Daten aus dem Carrier zu extrahieren.

Der Tracer hält eine \textbf{Scopemanager} Instanz. Der Scopemanager verwaltet die Spans. Über den Scopemanager kann der Tracer den aktuell aktiven Span ermitteln.


\subsection{Span}
\label{subsection:Span}
Der Span ist beinhaltet alle relevanten Daten, die für das Repäsentieren eines Events in einem System notwendig sind. Darunter zählt ein Operationsname. Der Operationsname kann beispielsweise die Sematik des Events beschreiben. Auch bietet sich ein Funktionsname innerhalb der Anwendung an, falls der Span genau diesen umfasst. Der \textbf{Startzeitstempel} und der \textbf{Endzeitstempel} beschreibt die Zeitspanne, in der das Event stattfindet. Diese sind in der Implementierung \emph{Datetime} instanzen. Das Datetimeformat, welches für die tracinginfrastruktur genutzt wird, hat folgenden Aufbau:

\begin{minipage}[]{\textwidth}
	\begin{lstlisting}[frame=trBL]
	MM/dd/yyyy hh:mm:ss.ffff tt
	\end{lstlisting}
	\captionof{lstlisting}{Zeitstempelformat der Spans}
	\label{listing:Tracer Verbindungsaufbau}
\end{minipage} 

Der Aufbau orientiert sich an dem amerikanischen Zeitformat. \textbf{MM} steht für den Monat, \textbf{dd} für den Tag und \textbf{yyyy} für das Jahr. Interessanter wird es bei dem Tageszeitformat, den in einem System bei dem Zeit eine kritische Rolle spielt, sind kleinste Zeitunterschiede von Bedeutung. \textbf{hh} und \textbf{mm} sind entsprechend die Stunden und Minunten. \textbf{ss.ffff} entspricht den Sekunden und dem tausendstel einer Sekunde. Die \textbf{Systemuhr Resolution} ist an dieser Stelle erwähnenswert. Die Resolution einer Uhr beschreibt die kleinste Einheit von Zeit, die akkurat von einer Uhr gemessen werden kann. Die Resolution der Systemuhr hängt von dem Betriebsystem ab. In einem Windows 8  Betriebsystem ist die Standardresolution bei 15.6 ms. Das .NET Framework, welches für die Implementierung genutzt wird, behandelt verschiedene Timer wiederum eigenständig. Diese kann manuell auf 0.5 reduziert werden. In einem Linux-basierenden Betriebssystem hängt die Resolution von der Software Clock ab. Dabei wird die Zeit in sog. \textbf{Jiffies} gemessen. Die Linux-Kernel version 2.6.0 führt eine jiffiegröße von 0.001 sekunden ein\footpartcite{mantime}. Dementsprechen sind die gemessenen Zeitstempel mit diesen Hintergrundinformationen zu bewerten.

Ein Span besitzt einen Spankontext und eine Referenzliste. Der Inhalt des Spankontext wird in \cref{subsection:SpanContext} beschrieben. Die Referenzliste beinhaltet alle Spans, die eine \textbf{Happens-Before Relation} zu dem Span aufweisen. Das bedeutet, das alle Elternspans, beispielsweise aus \emph{Child-Of} und \emph{Follows-From} resultierenden Beziehungen, in dieser Liste referenziert werden.

Schlussendlich kennt ein Span seinen Tracer. Dies ist erforderlich, da beim fertigstellen des Spans die \emph{Finish} Funktion aufgerufen wird. Diese sorgt dafür, das der Endzeitstempel gesetzt wird. Ausserdem wird die \emph{Report} Funktion der Reporterinstanz, bekannt durch den Tracer, aufgerufen.

\subsection{SpanBuilder}
\label{subsection:SpanBuilder}

Der SpanBuilder ist die Bindegliedentität zwischen dem Tracer und der Spangenerierung. Der Anwender der Instrumentalisierungsbibliothek kann durch die \emph{BuildSpan} Funktion des Tracer die Spangenerierung einleiten. Dabei wird eine SpanBuilder Instanz erstellt, die die übergebenen Parameter zur Spangenerierung nutzt. Der SpanBuilder verlangt bei der Initialisierung nach einem Operationsnamen und der Referenz des aufrufenden Tracers. Diese werden als Felder in der SpanBuilder Instanz gespeichert. Durch die Funktionen \emph{AddReference} und \emph{AsChildOf} kann das Feld \emph{references} bearbeitet werden. Dabei ist AsChildOf eine spezialisierte Form der AddReference Funktion. Die AddReference Funktion erwartet einen Referenztypen und einen SpanContext als Paramenter. Diese werden dann für den zu bauenden Span genutzt. 

Eine weitere Grundfunktion ist die \emph{Start} Funktion. Diese beinhaltet die nötige Anwendungslogik, für die Traceidentifikationsnummergenerierung. Auch die Spanidentifikationsnummer wird generiert. Anschließend wird der Span gebaut und mit den gesammelten Daten initialisiert.

Auch von der Start Funktion gibt es Spezialisierungen. Die überladene \emph{StartActive} Funktion kann Parameterlos oder mit dem Boolean \emph{finishSpanOnDispose} aufgerufen werden. Der Boolean bestimmt, wie mit einem Span umgegangen wird, nachdem die entsprechende Finish Funktion aufgerufen worden ist. StartActive setzt den gebauten Span auf den Zustand \textbf{Aktiv}. Das bedeutet, dass der Scopemanager diesen verfolgt und gegebenfalls den vorherig aktiven Span zwischenspeichert.

Eine beispielhafte Nutzung des Spanbuilders sieht folgendermaßen aus:

\begin{minipage}[]{\textwidth}
	\begin{lstlisting}[frame=trBL]
	var operationname = "example_function";
	var spanBuilder = tracer.BuildSpan(operationname);
	var span = spanBuilder.Start();
	\end{lstlisting}
	\captionof{lstlisting}{Beispielhafte Anwendung des SpanBuilder}
	\label{listing:SpanBuiler}
\end{minipage} 

Ein Operationsname wird definiert und als Paramenter für die BuildSpan-Funktion genutzt. Anschließend wird durch die Start-Funktion der SpanBuilder-Instanz ein Span auf den Zustand Aktiv gesetzt.


\subsection{SpanContext}
\label{subsection:SpanContext}

Die SpanContext-Klasse beinhaltet eine TraceId, eine SpanId und einen Rerenztypen als Felder. Diese werden bei der Initialisierung gesetzt. Die SpanContext-Klasse ist ein reine Datenkapselung. Semantisch sind die in der SpanContext enthaltenen Daten jene, die in einem BinaryCarrier, codiert als Bytearray, über die Leitung gesendet werden.

Ein Auszug eines Spankontexts aus dem Entwicklungssystem zeigt den Aufbau. Der Auszug stammt aus dem Registryservice. In dem Service wird der Nachricht auf die Konsole ausgebenen, sobald eine Propagiererung ausgelöst worden ist.

\begin{minipage}[]{\textwidth}
	\begin{lstlisting}[frame=trBL]
	traktor-registry_1 | Client-Message: WIoJiNwldhLM;ZtDdH4lQ1a1b;child_of
	\end{lstlisting}
	\captionof{lstlisting}{Ein über die Registry propagierter Spankontext}
	\label{listing:SpanContext-Registry}
\end{minipage} 

Der Spankontext beinhaltet drei Daten. Eine TraceId, eine SpanId und einem Relationstyp.

\subsection{Scope}
\label{subsection:Scope}

Ein Scope ist lokaler Kontext, welcher von dem ScopeManager verwaltet wird. In einem Scope werden Spans verwaltet. Dadurch wird das in \cref{subsection:Tracingcontext innerhalb eines Systems} beschriebene Problem der Kontextverfolgbarkeit innerhalb eines Systems gelöst. Ein Scope wird in einem Prozess geführt. Innerhalb des Scopes wird bei der aktiven Spans bei seiner Ersetzung gespeichert. Dadurch ist bei einer Beendigung des aktiven Spans der vorherige Span wiederherstellbar. Traktor nutzt die CSharp Implementierung des OpenTracing-Projekts.

\subsection{ScopeManager}
\label{subsection:ScopeManager}
Ein ScopeManager verwaltet Scopes. Bei einem Kontextwechsel, zum Beispiel bei einer Multi-Thread Implementierung, werden die Scopes durch den Manager verfolgt. Ein Scope ist nur innerhalb seines Prozesses relevant und beinhaltet einen aktiven Span. Über den Spanmanager lässt sich der Span, welcher durch einen aktiven Scope umfasst wird, ermitteln. Der Tracer ist dadurch jederzeit in der Lage, den aktiven Span und seinen Kontext zu nutzen. Wie auch der Scope, wird die ScopeManager-Implementierung des OpenTracing-Projekts genutzt. 

\subsection{Reporter}
\label{subsection:Reporter}
Die Reporter-Klasse kapselt die UDP-Verbindung des Tracers zu dem Agentenservice. Dabei wird die Netzwerkddresse, sowie der Port gespeichert. Bei der Initialisierung des Reporters, wird die Verbindung mit den gegebenen Parametern hergestellt.

Die Reporter-Klase umfasst drei Funktionen. Die Funktion \emph{Connect} stellt mit gegebenen Parametern die Verbindung zu dem UDP-Service her. Der UDP-Klient wird als Feld gespeichert und kann zur weiteren Datenübertragung genutzt werden. Die Funktion \emph{Report} sendet kodierte Form des Spans zu dem Agentenservice. Die Kodierung wird durch die Funktion \emph{BuildMessage} implementiert. Traktor nutzt eine UTF-8 Kodierung für den Nachrichtenaustausch.

\subsection{UML-Klassendiagramm der Bibliothek}
\label{subsection:UML-Klassendiagramm der Bibliothek}

Die Instrumentalisierungsbibliothek ist in der Programmiersprache CSharp implementiert. Die Programmiersprache eignet sich für die Entwicklung von Systemkomponenten, die in einer verteilten System zum Einsatz kommen, wie aus der Spezifikation der Programmiersprache entnommen werden kann: 

\begin{quote}
	\cbstart
	C\# ist gedacht als simple, moderne,  universal einsetzbare, objektorientierte Programmiersprache. [...] Die Sprache ist für die Entwicklung von Softwarekomponenten gedacht, die in einer verteilten Umgebung bereitgestellt werden.\footpartcite[S. xx]{10.5555/861332}
	\cbend
\end{quote}

Das Klassendiagramm, gezeigt in \cref{fig:TraktorKlassendiagramm}, stellt einen Überblick über die vorherig beschriebenen relevanten Entitäten der Bibliothek dar.

\newpage
\begin{landscape}
	\begin{figure}
		\centering
		\includegraphics[scale=0.4]{img/Implementierung/TraktorKlassendiagramm.png}
		\caption[Klassendiagramm der Traktor Instrumentalisierungsbibliothek]{Klassendiagramm der Traktor Instrumentalisierungsbibliothek}
		\label{fig:TraktorKlassendiagramm}
	\end{figure}
\end{landscape}

\section{Traktor Agent}
\label{section:Traktor Agent}

Der Traktoragent ist ein Service, welcher ein UDP-Endpunkt bereit stellt. Der Service gibt alle erhaltenen Nachrichten auf seiner Konsole aus. Zwei Umgebungsvariablen werden genutzt, um den UDP-Endpunkt zu initialisieren. Die \textbf{UDP\_IP} ist der \emph{Localhost}, da der Service auf einer eigenständigen Komponeten bereitgestellt wird. Dies ist durch den Spezifikikationspunkt \textbf{TE}.2  gegeben. Der belegete Port wird durch die Umgebungsvariable \textbf{UDP\_PORT} konfiguriert. 

Ein reporteter Span kann folgendermaßen aussehen:

\begin{minipage}[]{\textwidth}
	\begin{lstlisting}[frame=trBL]
	traktor-agent_1| recieved message: 
		 b'Process Context;
		 04/14/2020 10:10:06.1791 PM;
		 WIoJiNwldhLM;ZtDdH4lQ1a1b;
		 child_of;
		 04/14/2020 10:10:06.4158 PM'
	traktor-agent_1| from:  ('172.22.0.5', 13338)
	\end{lstlisting}
	\captionof{lstlisting}{Ein reportetet Span. Der gezeigte Span ist in der Webserver Entwicklungsumgebung generiert worden}
	\label{listing:Reporteter-Span}
\end{minipage} 

Der Service \emph{traktor-agent\_1} erhält von der Netzwerkaddresse 172.22.0.5:13338 die dargestellte Nachricht eines Spans mit dem Operationsnamen \emph{Process Context}. Der Startzeitstempel und der Endzeitstempel sind Teil des reporteten Spans. Auch der Spankontext ist dargestellt.

\section{Traktor Registry}
\label{section:Traktor Registry}

Die Traktor Registry ist ein Websocket Server. Verbindungsanfragen, initiiert von einer Tracerinstanz, werden als eigenständiger Thread in eine Klientenliste gespeichert der Registry gespeichert. Die Anwendungslogik der \emph{ClientHandler}-Threads implementiert die Websocket Handshakes. Das Websocketprotokoll wird in \cref{subsection:Websocketprotokoll} beschrieben. Die Kontextpropagierung wird durch den Websocket Server umgesetzt. Die Implementierung wird in \cref{subsection:Klientenverwaltung} vorgestellt.

\subsection{Websocketprotokoll}
\label{subsection:Websocketprotokoll}

Das Websocketprotokoll ermöglicht eine vollduplex Kommunikation zwischen der Registry und dem entsprechenden Websocketclient eines Tracers. Das Protokoll nutzt dafür eine einzige TCP-Verbindung. Das Websocketprotokoll wird genutzt, um einen geringen \textbf{Overhead} der Kommunikation zu gewährleisten. Dementsprechend wird das Designziel der \textbf{Verarbeitungskosten} berücksichtigt. Das Websocketprotokoll ist durch \gls{rfcLabel} mit der Nummer 6455 spezifiziert.

Das Websocketprotokoll verlangt einen öffnenden Handshake zur Etablierung der Verbindung. Dieser basiert auf einem HTTP Handshake. Die eröffnende HTTP-Anfrage beinhaltet eine \emph{Upgrade}-Anforderung der in diesem Moment genutzten HTTP-Verbindung. Der folgende Logausschnitt zeigt eine solche Eröffnungsnachricht:

\begin{minipage}[]{\textwidth}
	\begin{lstlisting}[frame=trBL]
	GET / HTTP/1.1
	Host: traktor-registry:8090
	Connection: Upgrade
	Upgrade: websocket
	Sec-WebSocket-Version: 13
	Sec-WebSocket-Key: s4VKefPmikGz1rJ24buoaQ==
	\end{lstlisting}
	\captionof{lstlisting}{Eröffnende Nachricht eines Websocket Handshake}
	\label{listing:Eröffnender Websocket Handshake}
\end{minipage} 

Die HTTP-Nachricht beinhaltet sogenannte \textbf{Header}, die Daten beinhalten, die für den Protokollwechsel von HTTP zu Websocket nötig sind. Der Host-Header identifiziert den Ursprung des Handshakeinitiators. Dieser ist in diesem Falle die IP-Addresse die hinter dem Alias \emph{traktor-registry} steht. Der Port 8090 der Anwendung, von welchem die Anfrage stammt, wird zusätzlich mitgesendet. Der Connection-Header gibt die bervorzugte Verbindungsart an. Diese beschreibt den gewünschten Vorgang eines Upgrades der Verbindung. In Verbindung mit dem Inhalt des Connections-Headers wird ein Upgrade-Header gesendet. Dieser ist ein Vorschlag an den Server ein anderes Protokoll zu nutzen. Entsprechend beinhaltet der Upgrade-Header den Vorschlag das Websocket Protokoll zu verwenden. Die letzen beiden Header Sec-WebSocket-Version und Sec-WebSocket-Key sind websocketspezifische Header.

Die Serverantwort sieht ähnlich aus. Diese besteht aus der Request-Line und dem Sec-WebSocket-Accept Header, der eine Bestätigung der zu nutzenden Websocketverbindung darstellt.

\begin{minipage}[]{\textwidth}
	\begin{lstlisting}[frame=trBL]
	HTTP/1.1 101 Switching Protocols
	Upgrade: websocket
	Connection: Upgrade
	Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=
	\end{lstlisting}
	\captionof{lstlisting}{Serverantwort eines Websocket Handshake}
	\label{listing:Serverantwort eines Websocket Handshake}
\end{minipage} 

\subsection{Klientenverwaltung}
\label{subsection:Klientenverwaltung}



\section{Unity Rendering System}
\label{section:Unity Rendering System}
\section{ Webserver Entwicklungsumgebung }
\label{section:Webserver Entwicklungsumgebung}
% ----------------------------------------------------------------------------
