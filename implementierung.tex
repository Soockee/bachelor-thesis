% ----------------------------------------------------------------------------
% Copyright (c) 2016 by Burkhardt Renz. All rights reserved.
% Die Vorlage für eine Abschlussarbeit in der Informatik am Fachbereich
% MNI der THM ist lizenziert unter einer Creative Commons
% Namensnennung-Nicht kommerziell 4.0 International Lizenz.
%
% Id:$
% ----------------------------------------------------------------------------
\chapter{Implementierung}
\label{chapter:Implementierung}

In diesem Kapitel werden Implementierungen von Prototypen gezeigt, die im Kapitel \cref{chapter:Design} besprochen sind. In \cref{section:Instrumentalisierungsbibliothek: Traktor} werden die implementierungsdetails der Instrumentalisierungsbilbiothek \textbf{Traktor} vorgestellt. In \cref{section:Traktor Agent} und in \cref{section:Traktor Registry} werden die Traktor Services beschrieben. Anschließend werden zwei Anwendungsfälle gezeigt. Der Anwendungsfall des rendering System in \cref{section:Unity Rendering System} und der Anwendungsfall einer verteilten Webanwendung in \cref{section:Webserver Entwicklungsumgebung}

\section{Instrumentalisierungsbibliothek: Traktor}
\label{section:Instrumentalisierungsbibliothek: Traktor}
In diesem Kapitel wird die Implementierung der Instrumentalisierungsbibliothek Traktor vorgestellt. Es wird das Datenmodell umgesetzt, welches in \cref{section:Datenmodell} konzipiert ist und gezeigt inwiefern Traktor die Anforderungen erfüllt.

Traktor ist eine Instrumentalisierungsbibliothek, die sich die OpenTracing API als Vorbild nimmt. Die OpenTracing API ist eine herstellerneutrale instrumentalisierungs API, die unter der Schirmherschafft der \gls{cncfLabel} steht, welches Teil der gemeinnützig agierenden \gls{lfLabel} ist.

Die Traktor Instrumentalisierungsbibliothek beinhaltet zwei wichtie Einheiten. Das ist zum einen der \textbf{Tracer} und zum anderen \textbf{Spans}. 

\textbf{Span}\space\space\space Die Spans tragen die Daten, die für eine Ordnungsbildung notwendig sind. Das sind zum einen die Zeitstempel der Startzeit und der Endzeit der ausgeführten arbeit, sowie Identifikationsnummer zur identifizierung der Spans. Die Identifizierung muss durch zwei Daten gegeben sein. Die TraceID stellt die zugehörigekeit eines Spans zu einem Trace dar. Die SpanID ist die Nummer, die ein Span innerhalb eines Traces von anderen Spans unterscheidbar macht. Ein Spankontext wird im Span gespeichert. Dieser stellt gegebenenfalls die nötige Relation zu einem Elternspan her. Durch die Verfolgung der Kontextinhalte, lassen sich die Traces rekonstruieren und eine anschließene Analyse beziehungsweise eine Visualisierung durchführen.

\subsection{Tracer}
\label{subsection:Tracer}
Der Tracer ist die zentrale Verwaltungseinheit der Instrumentalisierung. Dieser verwaltet die Verbindung der Anwendungsinstrumentalisierung zu dem Agenten und der Registry. Der Tracer kümmert sich um das Generieren von Spans und die Herstellung von Kausalzusammenhängen zwischen den Spans. Ausserdem stellt der Tracer die Funktionalitäten zur Kontextpropagierung über die Registry bereit. Die Spans sind Darstellungen von ausgeführter Arbeit in einer instrumentalisierten Anwendung. 

Die Tracer API erweitert die OpenTracing API um vier Funktionen, die notwendig sind, um sich mit der Tracinginfrastuktur zu verbinden. Die \emph{Configure} Funktion sorgt für einen Verbindungsaufbau, abhängig von den übergebenen Parametern. Ein vollständiger Verbindungsaufbau ist nötig, um eine Kontextpropagierung zu ermögliche. Ausserdem wird der Udp Klient initzialisiert, damit beendete Spans reportet werden können. Der Udp klient hat einen Port zu belegen, der angegeben werden muss. Die IP-Adressen der Services sind dem Tracer bekannt zu geben. Auch der Port auf der die Anwendung lauscht, muss übergeben werden. Die Configure Funktion verwendet die \emph{Register} Funktion zur Erstellung einer \textbf{WebSocketClient} Instanz. Die Websocketverbindung wird über die Lebensdauer des Tracer offen gehalten. Über diesen Kommunikationskanal werden die Kontextinformationen übermittelt. \cref{listing:Tracer Verbindungsaufbau} zeigt eine Beispielhafte Konfigurierung. Dabei wird eine Tracerinstanz instanziiert und mit den Adressen der Traktorservices konfiguriert.

\begin{minipage}[]{\textwidth}
	\begin{lstlisting}[frame=trBL]
	using Traktor;
	
	var registryAddress = "localhost";
	var registryPort = "8080";
	var agentAddress = "localhost"
	var agentPort = 13337;
	var reporterPort = 13338;
	
	Tracer tracer = new Tracer()
	tracer.Configure(registryAddress,registryPort,agentAddress,
				agentPort,reporterPort);
	
	\end{lstlisting}
	\captionof{lstlisting}{Tracer Verbindungsaufbau mit der Registry und dem Reporter }
	\label{listing:Tracer Verbindungsaufbau}
\end{minipage} 

Die Kontextdaten werden in einer \emph{Carrier} Instanz gespeichert und über die Leitung gesendet. In der Implementierung gibt es einen Carriertyp. Der BinaryCarrier ist ein Datencontainer, der die Kontextinformationen als MemoryStream speichert. Der MemoryStream speichert die Daten im Arbeitsspeicher als Bytearray. Das Format würde für die Übertragung über eine TCP/IP Verbindung ausgewählt. 
Die Spangenerierung wird durch eine \emph{SpanBuilder} Instanz geregelt. Der Operationsname wird der SpanBuilder Instanz mitgegeben und für die Generierung des Spans genutzt. Die Kontextpropagierung wird durch die beiden sich ergänzenden asynchronen Funktionen \emph{SendContext} und \emph{ReceiveContext} implementiert. Diese nutzen die \emph{Extract} und \emph{Inject}, um die BinaryCarrier zu erstellen beziehungsweise die Daten aus dem Carrier zu extrahieren.

Der Tracer hält eine \textbf{Scopemanager} Instanz. Der Scopemanager verwaltet die Spans. Über den Scopemanager kann der Tracer den aktuell aktiven Span ermitteln.


\subsection{Span}
\label{subsection:Span}
Der Span ist beinhaltet alle relevanten Daten, die für das Repäsentieren eines Events in einem System notwendig sind. Darunter zählt ein Operationsname. Der Operationsname kann beispielsweise die Sematik des Events beschreiben. Auch bietet sich ein Funktionsname innerhalb der Anwendung an, falls der Span genau diesen umfasst. Der \textbf{Startzeitstempel} und der \textbf{Endzeitstempel} beschreibt die Zeitspanne, in der das Event stattfindet. Diese sind in der Implementierung \emph{Datetime} instanzen. Das Datetimeformat, welches für die tracinginfrastruktur genutzt wird, hat folgenden Aufbau:

\begin{minipage}[]{\textwidth}
	\begin{lstlisting}[frame=trBL]
	MM/dd/yyyy hh:mm:ss.ffff tt
	\end{lstlisting}
	\captionof{lstlisting}{Zeitstempelformat der Spans}
	\label{listing:Tracer Verbindungsaufbau}
\end{minipage} 

Der Aufbau orientiert sich an dem amerikanischen Zeitformat. \textbf{MM} steht für den Monat, \textbf{dd} für den Tag und \textbf{yyyy} für das Jahr. Interessanter wird es bei dem Tageszeitformat, den in einem System bei dem Zeit eine kritische Rolle spielt, sind kleinste Zeitunterschiede von Bedeutung. \textbf{hh} und \textbf{mm} sind entsprechend die Stunden und Minunten. \textbf{ss.ffff} entspricht den Sekunden und dem tausendstel einer Sekunde. Die \textbf{Systemuhr Resolution} ist an dieser Stelle erwähnenswert. Die Resolution einer Uhr beschreibt die kleinste Einheit von Zeit, die akkurat von einer Uhr gemessen werden kann. Die Resolution der Systemuhr hängt von dem Betriebsystem ab. In einem Windows 8  Betriebsystem ist die Standardresolution bei 15.6 ms. Das .NET Framework, welches für die Implementierung genutzt wird, behandelt verschiedene Timer wiederum eigenständig. Diese kann manuell auf 0.5 reduziert werden. In einem Linux-basierenden Betriebssystem hängt die Resolution von der Software Clock ab. Dabei wird die Zeit in sog. \textbf{Jiffies} gemessen. Die Linux-Kernel version 2.6.0 führt eine jiffiegröße von 0.001 sekunden ein\footpartcite{mantime}. Dementsprechen sind die gemessenen Zeitstempel mit diesen Hintergrundinformationen zu bewerten.

Ein Span besitzt einen Spankontext und eine Referenzliste. Der Inhalt des Spankontext wird in \cref{subsection:SpanContext} beschrieben. Die Referenzliste beinhaltet alle Spans, die eine \textbf{Happens-Before Relation} zu dem Span aufweisen. Das bedeutet, das alle Elternspans, beispielsweise aus \emph{Child-Of} und \emph{Follows-From} resultierenden Beziehungen, in dieser Liste referenziert werden.

Schlussendlich kennt ein Span seinen Tracer. Dies ist erforderlich, da beim fertigstellen des Spans die \emph{Finish} Funktion aufgerufen wird. Diese sorgt dafür, das der Endzeitstempel gesetzt wird. Ausserdem wird die \emph{Report} Funktion der Reporterinstanz, bekannt durch den Tracer, aufgerufen.

\subsection{SpanBuilder}
\label{subsection:SpanBuilder}

\subsection{SpanContext}
\label{subsection:SpanContext}

\subsection{Scope}
\label{subsection:Scope}

\subsection{ScopeManager}
\label{subsection:SpanManager}

\subsection{Reporter}
\label{subsection:Reporter}
\newpage
\begin{landscape}
	\begin{figure}
		\centering
		\includegraphics[scale=0.4]{img/Implementierung/TraktorKlassendiagramm.png}
		\caption[Klassendiagramm der Traktor Instrumentalisierungsbibliothek]{Klassendiagramm der Traktor Instrumentalisierungsbibliothek}
		\label{fig:TraktorKlassendiagramm}
	\end{figure}
\end{landscape}

\section{Traktor Agent}
\label{section:Traktor Agent}
\section{Traktor Registry}
\label{section:Traktor Registry}
\section{Unity Rendering System}
\label{section:Unity Rendering System}
\section{ Webserver Entwicklungsumgebung }
\label{section:Webserver Entwicklungsumgebung}
% ----------------------------------------------------------------------------
